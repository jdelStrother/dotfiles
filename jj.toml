[user]
name = "Jonathan del Strother"
email = "me@delstrother.com"

[ui]
default-command = "logstatus"
pager = ":builtin"
# conflict-marker-style = "git"
# diff-editor = ":builtin"
diff-editor = "gitpatch"
merge-editor = "ksdiff"

[signing]
behavior = "drop"
backend = "ssh"
key = "~/.ssh/id_ed25519.pub"

[git]
sign-on-push = true
private-commits = '''description(glob:'private:*')'''
push-new-bookmarks = true # don't require --allow-new
write-change-id-header = true

[aliases]
logstatus = ["util", "exec", "--", "bash", "-c", """
    jj log -r 'ancestors(reachable(@, ~(::trunk())), 2)' --no-pager
    jj status
"""]
pr = ["util", "exec", "--", "bash", "-c", """
#!/usr/bin/env bash
set -euo pipefail
rev=non_empty_head
if [ "$#" -gt 0 ]; then
  if [ "$1" = "-r" ]; then
    shift
    rev="$1"
    shift
  fi
fi
if [ "$#" -gt 0 ]; then
  name="$1"
else
  prompt="Suggest a really short git branch name from the list of commits on stdin in json format. Pay special attention to the first line in each commit. Don't use any 'fix'/'feat'/etc prefixes. Output just the branch name, no quotes"
  name="$( jj log -r "trunk()..$rev ~empty()" --no-graph -T 'description.escape_json()++"\n"' | jq -s | llm -x "$prompt" )"
fi
bookmark="$(jj config get jds.pr-prefix)$name"
jj git push --named "$bookmark=$rev"
gh pr create --head "$bookmark" --web
""", ""]
tug = ["util", "exec", "--", "bash", "-c", """
  jj bookmark move --from "closest_bookmark(${1:-non_empty_head})" --to "${1:-non_empty_head}"
""", ""]
sync = ["util", "exec", "--", "bash", "-c", """
  jj git fetch --branch master --branch 'glob:jon/*' && jj rebase -d master && jj simplify-parents
""", ""]


# "Back" button for the working directory: go back to the last change that @ was
# editing.
back = ["util", "exec", "--", "bash", "-c", """
    resolve () { jj log --no-graph -r@ -T'change_id.short() ++ "\\n"' "$@"; }
    current=$(resolve)
    jj op log --no-graph -T 'id.short() ++ "\\n"' | while read op; do
        old=$(resolve --at-op $op)
        if [[ $old != $current ]]; then
            if ! jj edit $old 2>/dev/null; then
                old_commit=$(jj evolog -r $old --at-op $op --no-graph -T 'commit_id.short() ++ "\\n"' | sed -n '1p')
                jj edit $old_commit
            fi
            exit 0
        fi
    done
""", "jj-back"]

# Assumes the existence of a 'megamerge' revset alias and 'trunk()' resolving
# properly to a single commit. Then 'jj sandwich xyz' to move xyz into the
# megamerge in parallel to everything else.
sandwich = [ "rebase", "-B", "megamerge", "-A", "trunk()", "-r"]

# Usage: jj addparent <child aka mergerev> <newparent>
#
# jj rebase -s <mergerev> -d <mergerev>- -d <newparent>
addparent = ["util", "exec", "--", "bash", "-c", '''
    jj rebase -s $1 -d "$1-" -d $2
''', "jj-addparent"]

# Usage: jj rmparent <child aka mergerev> <oldparent>
#
# jj rebase -s <mergerev> -d "<mergerev>- ~ <oldparent>"
rmparent = ["util", "exec", "--", "bash", "-c", '''
    jj rebase -s $1 -d "$1- ~ $2"
''', "jj-rmparent"]

[revsets]
'log' = 'present(@) | ancestors((immutable_heads()|dead_bookmarks).., 2) | present(trunk())'

[revset-aliases]
'remote' = '::remote_bookmarks()'
'closest_bookmark(to)' = 'heads(::to & bookmarks())'
'non_empty_head' = 'latest((@ | @-) & ~empty())'
# overridden in each repository to hide old branches
'dead_bookmarks' = 'none()'
'live_bookmarks' = 'bookmarks() ~ dead_bookmarks'

[merge-tools.ediff]
program = 'sh'
merge-args = ['-x', '-c', 'emacsclient -nw -c --eval "(jds/ediff-merge-files-with-ancestor \"$0\" \"$1\" \"$2\" nil \"$3\")"', '$left', '$right', '$base', '$output']

[merge-tools.difft]
diff-args = ["--color=always", "--sort-paths", "$left", "$right"]

[merge-tools.ksdiff]
diff-invocation-mode = "file-by-file"
diff-args = ["--partial-changeset", "$left", "$right"]
merge-args = ["--merge", "--output", "$output", "--base", "$base", "$left", "$right"]

[merge-tools.gitpatch]
program = "sh"
edit-args = ["-c", '''
  set -eu
  rm -f "$right/JJ-INSTRUCTIONS"
  git -C "$left" init -q
  git -C "$left" add -A
  git -C "$left" commit -q -m baseline --allow-empty
  mv "$left/.git" "$right"
  git -C "$right" add --intent-to-add --ignore-removal . # tell git to include new files in interactive patch mode
  git -C "$right" add -p
  git -C "$right" diff-index --quiet --cached HEAD && { echo "No changes done, aborting split."; exit 1; }
  git -C "$right" commit -q -m split
  git -C "$right" reset -q --hard # undo changes in modified files, remove added files
''',
]
merge-args = ["-c", "echo gitpatch cannot be used as a diff tool"]
diff-args = ["-c", "echo gitpatch cannot be used as a diff tool"]

[colors]
# "diff removed token" = { fg = "bright red", bg = "#400000", underline = false }
# "diff added token" = { fg = "bright green", bg = "#003000", underline = false }


[templates]
draft_commit_description = '''
    concat(
    coalesce(description, "\n"),
    surround(
        "\nJJ: This commit contains the following changes:\n", "",
        indent("JJ:     ", diff.stat(72)),
    ),
    "\nJJ: ignore-rest\n",
    diff.git(),
    )
'''

[jds]
pr-prefix = ""
