[user]
name = "Jonathan del Strother"
email = "me@delstrother.com"

[ui]
default-command = "log_with_status"
pager = ["less", "-FRXi"]
# conflict-marker-style = "git"
diff-editor = ":builtin"
merge-editor = "ksdiff"

[signing]
behavior = "drop"
backend = "ssh"
key = "~/.ssh/id_ed25519.pub"

[git]
sign-on-push = true
private-commits = '''description(glob:'private:*')'''
write-change-id-header = true

[aliases]
gitpatch = ["commit", "-i", "--tool", "gitpatch"]
solve = ["resolve", "--tool", "mergiraf"]
log_with_status = ["log", "-T", "log_with_status", "-r", "ancestors(reachable(@, ~(::trunk())), 2)"]

logstatus = ["util", "exec", "--", "bash", "-c", """
    jj log -r 'ancestors(reachable(@, ~(::trunk())), 2)' --no-pager
    jj status
"""]
pr = ["util", "exec", "--", "jj-pr"]

tug = ["util", "exec", "--", "bash", "-c", """
  jj bookmark move --from "closest_bookmark(${1:-non_empty_head})" --to "${1:-non_empty_head}"
""", ""]

sync = ["util", "exec", "--", "bash", "-c", """
  jj git fetch --branch 'glob:master*' --branch 'glob:main*' --branch 'glob:jon/*' &&
  jj rebase -d 'trunk()' --skip-emptied && 
  jj simplify-parents
""", ""]


# "Back" button for the working directory: go back to the last change that @ was
# editing.
back = ["util", "exec", "--", "bash", "-c", """
    resolve () { jj log --no-graph -r@ -T'change_id.short() ++ "\\n"' "$@"; }
    current=$(resolve)
    jj op log --no-graph -T 'id.short() ++ "\\n"' | while read op; do
        old=$(resolve --at-op $op)
        if [[ $old != $current ]]; then
            if ! jj edit $old 2>/dev/null; then
                old_commit=$(jj evolog -r $old --at-op $op --no-graph -T 'commit.commit_id().short() ++ "\\n"' | sed -n '1p')
                jj edit $old_commit
            fi
            exit 0
        fi
    done
""", "jj-back"]

# Assumes the existence of a 'megamerge' revset alias and 'trunk()' resolving
# properly to a single commit. Then 'jj sandwich xyz' to move xyz into the
# megamerge in parallel to everything else.
sandwich = [ "rebase", "-B", "megamerge", "-A", "trunk()", "-r"]

# Usage: jj addparent <child aka mergerev> <newparent>
#
# jj rebase -s <mergerev> -d <mergerev>- -d <newparent>
addparent = ["util", "exec", "--", "bash", "-c", '''
    jj rebase -s $1 -d "$1-" -d $2
''', "jj-addparent"]

# Usage: jj rmparent <child aka mergerev> <oldparent>
#
# jj rebase -s <mergerev> -d "<mergerev>- ~ <oldparent>"
rmparent = ["util", "exec", "--", "bash", "-c", '''
    jj rebase -s $1 -d "$1- ~ $2"
''', "jj-rmparent"]

[revsets]
'log' = 'present(@) | ancestors((immutable_heads()|dead_bookmarks).., 2) | present(trunk())'

[revset-aliases]
remote = '::remote_bookmarks()'
'closest_bookmark(to)' = 'heads(::to & bookmarks())'
non_empty_head = 'latest((@ | @-) & ~empty())'
# overridden in each repository to hide old branches
dead_bookmarks = 'none()'
live_bookmarks = 'bookmarks() ~ dead_bookmarks'
# The person I grabbed this from shows the diff on both @, and @- if the current description is empty.
# I'm not sure that's useful for my workflow
# diff_set = '@ | (@ & description(exact:""))-'
diff_set = '@'

[template-aliases]
log_with_status = '''
  builtin_log_compact(self)
  ++ if(self.contained_in("diff_set"), diff.summary())
'''

[merge-tools.ediff]
program = 'sh'
merge-args = ['-x', '-c', 'emacsclient -nw -c --eval "(jds/ediff-merge-files-with-ancestor \"$0\" \"$1\" \"$2\" nil \"$3\")"', '$left', '$right', '$base', '$output']

[merge-tools.difft]
diff-args = ["--color=always", "--sort-paths", "$left", "$right"]

[merge-tools.ksdiff]
diff-invocation-mode = "file-by-file"
diff-args = ["--partial-changeset", "$left", "$right"]
merge-args = ["--merge", "--output", "$output", "--base", "$base", "$left", "$right"]

[merge-tools.gitpatch]
program = "sh"
edit-args = ["-c", '''
  set -eu
  rm -f "$right/JJ-INSTRUCTIONS"
  git -C "$left" init -q
  git -C "$left" add -A
  git -C "$left" commit -q -m baseline --allow-empty
  mv "$left/.git" "$right"
  git -C "$right" add --intent-to-add --ignore-removal . # tell git to include new files in interactive patch mode
  git -C "$right" add -p
  git -C "$right" diff-index --quiet --cached HEAD && { echo "No changes done, aborting split."; exit 1; }
  git -C "$right" commit -q -m split
  git -C "$right" reset -q --hard # undo changes in modified files, remove added files
''',
]
merge-args = ["-c", "echo gitpatch cannot be used as a diff tool"]
diff-args = ["-c", "echo gitpatch cannot be used as a diff tool"]

[colors]
# "diff removed token" = { fg = "bright red", bg = "#400000", underline = false }
# "diff added token" = { fg = "bright green", bg = "#003000", underline = false }


[templates]
draft_commit_description = '''
    concat(
    coalesce(description, "\n"),
    surround(
        "\nJJ: This commit contains the following changes:\n", "",
        indent("JJ:     ", diff.stat(72)),
    ),
    "\nJJ: ignore-rest\n",
    diff.git(),
    )
'''

[jds]
pr-prefix = ""

[remotes.origin]
auto-track-bookmarks = "glob:jon/*"
