[user]
name = "Jonathan del Strother"
email = "me@delstrother.com"

[ui]
default-command = "log_with_status"
pager = ":builtin"
# conflict-marker-style = "git"
diff-editor = ":builtin"
merge-editor = "ksdiff"

[signing]
behavior = "drop"
backend = "ssh"
key = "~/.ssh/id_ed25519.pub"

[git]
sign-on-push = true
private-commits = '''description(glob:'private:*')'''
push-new-bookmarks = true # don't require --allow-new
write-change-id-header = true

[aliases]
gitpatch = ["commit", "-i", "--tool", "gitpatch"]
solve = ["resolve", "--tool", "mergiraf"]
log_with_status = ["log", "-T", "log_with_status"]

logstatus = ["util", "exec", "--", "bash", "-c", """
    jj log -r 'ancestors(reachable(@, ~(::trunk())), 2)' --no-pager
    jj status
"""]
pr = ["util", "exec", "--", "bash", "-c", """
    set -euo pipefail
    rev=non_empty_head
    dry_run=false
    name=""
    while [ "$#" -gt 0 ]; do
      case "$1" in
        -r)
          shift
          rev="$1"
          shift
          ;;
        -n|--dry-run)
          dry_run=true
          shift
          ;;
        *)
          name="$1"
          shift
          break
          ;;
      esac
    done
    # automatically sandwich the revision(s) if they're not contained within megamerge
    revtip=$(jj log -T'change_id' --no-graph -n1 -r "$rev") # in case rev is a range, get a single commit from the tip
    if [ "$(jj log -n1 -r megamerge..$revtip)" != '' ]; then
      jj sandwich "$rev"
    fi
    rev="$revtip"

    if [ -z "$name" ]; then
      prompt="You are a git branch naming assistant. Given a series of git commits, generate a suitable branch name that captures the overall theme or purpose of the changes."'
Input format:
```json
{
  "commits": ["example commit subject 1\\n\\nexample commit description", "example commit 2"]
}
```

Output format:
```json
{ "name": "your-branch-name" }
```
'"
IMPORTANT: Return ONLY valid JSON. No additional text, explanations, or markdown formatting.

Guidelines for branch names:
- Use lowercase letters, numbers, and hyphens only
- Keep it short (2-5 words, max 40 characters)
- Be descriptive but concise
- Don't use directory-style prefixes (feature/, bugfix/, hotfix/, etc.)
- You can start with action words like 'fix', 'add', 'update', 'refactor', 'cleanup', 'remove'
- Focus on WHAT is being changed, not HOW

Examples of good branch names:
- 'cleanup-unused-code'
- 'fix-user-auth'
- 'refactor-share-buttons'
- 'add-podcast-analytics'
- 'update-session-handling'
- 'remove-deprecated-endpoints'

Examples of bad branch names:
- 'feature/user-auth' (uses directory prefix)
- 'fixes' (too vague)
- 'update-code-to-fix-bug-in-user-authentication-system' (too long, >40 chars)
- 'WIP-stuff' (unclear, uses capitals)
- 'myBranch123' (uses camelCase)

Special cases:
- If commits are unrelated, focus on the most significant or impactful change
- If commit messages are unclear or generic, extract the most descriptive elements available
- For a single commit, mirror the commit subject but conform to the naming rules above
- If changes span multiple areas, prioritize the user-facing or business-critical aspect
"
      name="$( jj log -r "trunk()..$rev ~empty()" --no-graph -T 'description.escape_json()++"\n"' | jq -s '{commits: .}' | llm -x "$prompt" | jq --raw-output .name )"
      if [[ ! "$name" =~ ^[a-z][-a-z]+$ ]]; then
        echo "Bad bookmark from the stupid llm: '$name'"
        exit 1
      fi
    fi
    bookmark="$(jj config get jds.pr-prefix)$name"
    if "$dry_run"; then
      echo Dry run! Would have run:
      echo jj git push --named "$bookmark=$rev"
      echo gh pr create --head "$bookmark" --web
    else
      jj git push --named "$bookmark=$rev"
      gh pr create --head "$bookmark" --web
    fi
""", ""]

tug = ["util", "exec", "--", "bash", "-c", """
  jj bookmark move --from "closest_bookmark(${1:-non_empty_head})" --to "${1:-non_empty_head}"
""", ""]

sync = ["util", "exec", "--", "bash", "-c", """
  jj git fetch --branch master --branch 'glob:jon/*' && jj rebase -d 'trunk()' --skip-emptied && jj simplify-parents
""", ""]


# "Back" button for the working directory: go back to the last change that @ was
# editing.
back = ["util", "exec", "--", "bash", "-c", """
    resolve () { jj log --no-graph -r@ -T'change_id.short() ++ "\\n"' "$@"; }
    current=$(resolve)
    jj op log --no-graph -T 'id.short() ++ "\\n"' | while read op; do
        old=$(resolve --at-op $op)
        if [[ $old != $current ]]; then
            if ! jj edit $old 2>/dev/null; then
                old_commit=$(jj evolog -r $old --at-op $op --no-graph -T 'commit.commit_id().short() ++ "\\n"' | sed -n '1p')
                jj edit $old_commit
            fi
            exit 0
        fi
    done
""", "jj-back"]

# Assumes the existence of a 'megamerge' revset alias and 'trunk()' resolving
# properly to a single commit. Then 'jj sandwich xyz' to move xyz into the
# megamerge in parallel to everything else.
sandwich = [ "rebase", "-B", "megamerge", "-A", "trunk()", "-r"]

# Usage: jj addparent <child aka mergerev> <newparent>
#
# jj rebase -s <mergerev> -d <mergerev>- -d <newparent>
addparent = ["util", "exec", "--", "bash", "-c", '''
    jj rebase -s $1 -d "$1-" -d $2
''', "jj-addparent"]

# Usage: jj rmparent <child aka mergerev> <oldparent>
#
# jj rebase -s <mergerev> -d "<mergerev>- ~ <oldparent>"
rmparent = ["util", "exec", "--", "bash", "-c", '''
    jj rebase -s $1 -d "$1- ~ $2"
''', "jj-rmparent"]

[revsets]
'log' = 'present(@) | ancestors((immutable_heads()|dead_bookmarks).., 2) | present(trunk())'

[revset-aliases]
'remote' = '::remote_bookmarks()'
'closest_bookmark(to)' = 'heads(::to & bookmarks())'
'non_empty_head' = 'latest((@ | @-) & ~empty())'
# overridden in each repository to hide old branches
'dead_bookmarks' = 'none()'
'live_bookmarks' = 'bookmarks() ~ dead_bookmarks'
'diff_set' = '@ | (@ & description(exact:""))-'

[template-aliases]
log_with_status = '''
  builtin_log_compact(self)
  ++ if(self.contained_in("diff_set"), diff.summary())
'''

[merge-tools.ediff]
program = 'sh'
merge-args = ['-x', '-c', 'emacsclient -nw -c --eval "(jds/ediff-merge-files-with-ancestor \"$0\" \"$1\" \"$2\" nil \"$3\")"', '$left', '$right', '$base', '$output']

[merge-tools.difft]
diff-args = ["--color=always", "--sort-paths", "$left", "$right"]

[merge-tools.ksdiff]
diff-invocation-mode = "file-by-file"
diff-args = ["--partial-changeset", "$left", "$right"]
merge-args = ["--merge", "--output", "$output", "--base", "$base", "$left", "$right"]

[merge-tools.gitpatch]
program = "sh"
edit-args = ["-c", '''
  set -eu
  rm -f "$right/JJ-INSTRUCTIONS"
  git -C "$left" init -q
  git -C "$left" add -A
  git -C "$left" commit -q -m baseline --allow-empty
  mv "$left/.git" "$right"
  git -C "$right" add --intent-to-add --ignore-removal . # tell git to include new files in interactive patch mode
  git -C "$right" add -p
  git -C "$right" diff-index --quiet --cached HEAD && { echo "No changes done, aborting split."; exit 1; }
  git -C "$right" commit -q -m split
  git -C "$right" reset -q --hard # undo changes in modified files, remove added files
''',
]
merge-args = ["-c", "echo gitpatch cannot be used as a diff tool"]
diff-args = ["-c", "echo gitpatch cannot be used as a diff tool"]

[colors]
# "diff removed token" = { fg = "bright red", bg = "#400000", underline = false }
# "diff added token" = { fg = "bright green", bg = "#003000", underline = false }


[templates]
draft_commit_description = '''
    concat(
    coalesce(description, "\n"),
    surround(
        "\nJJ: This commit contains the following changes:\n", "",
        indent("JJ:     ", diff.stat(72)),
    ),
    "\nJJ: ignore-rest\n",
    diff.git(),
    )
'''

[jds]
pr-prefix = ""
