#!/bin/bash

set -euo pipefail

rev=non_empty_head
dry_run=false
name=""
while [ "$#" -gt 0 ]; do
  case "$1" in
    -r)
      shift
      rev="$1"
      shift
      ;;
    -n|--dry-run)
      dry_run=true
      shift
      ;;
    *)
      name="$1"
      shift
      break
      ;;
  esac
done

 # in case rev is a range, get a single commit from the tip
revtip=$(jj log -T'change_id' --no-graph -n1 -r "$rev")
if jj show megamerge > /dev/null 2>&1 ; then
  # automatically sandwich the revision(s) if they're not contained within megamerge
  if [ "$(jj log -n1 -r megamerge.."$revtip")" != '' ]; then
    jj sandwich "$rev"
  fi
else
  # no megamerge ref? Assume this repo doesn't use one, and we just want to PR the rev as-is.
  :
fi
rev="$revtip"

if [ -z "$name" ]; then
  prompt="You are a git branch naming assistant. Given a series of git commits, generate a suitable branch name that captures the overall theme or purpose of the changes."'
Input format:
```json
{
"commits": ["example commit subject 1\\n\\nexample commit description", "example commit 2"]
}
```

Output format:
```json
{ "branch": "your-branch-name" }
```
'"

Guidelines for branch names:
- Use lowercase letters, numbers, and hyphens only
- Keep it short (2-5 words, max 40 characters)
- Be descriptive but concise
- Don't use directory-style prefixes (feature/, bugfix/, hotfix/, etc.)
- You can start with action words like 'fix', 'add', 'update', 'refactor', 'cleanup', 'remove'
- Focus on WHAT is being changed, not HOW

Examples of good branch names:
- 'cleanup-unused-code'
- 'fix-user-auth'
- 'refactor-share-buttons'
- 'add-podcast-analytics'
- 'update-session-handling'
- 'remove-deprecated-endpoints'

Examples of bad branch names:
- 'feature/user-auth' (uses directory prefix)
- 'fixes' (too vague)
- 'update-code-to-fix-bug-in-user-authentication-system' (too long, >40 chars)
- 'WIP-stuff' (unclear, uses capitals)
- 'myBranch123' (uses camelCase)

Special cases:
- If commits are unrelated, focus on the most significant or impactful change
- If commit messages are unclear or generic, extract the most descriptive elements available
- For a single commit, mirror the commit subject but conform to the naming rules above
- If changes span multiple areas, prioritize the user-facing or business-critical aspect
"
  printf "PR-ing\n%s" "$(jj log --color always -r "trunk()..$rev ~empty()")"
  name="$( jj log -r "trunk()..$rev ~empty()" --no-graph -T 'description.escape_json()++"\n"' | jq -s '{commits: .}' |
    claude --model haiku -p "$prompt" --json-schema '{"type":"object","properties":{"branch":{"type":"string"}},"required":["branch"]}' --output-format json |
    jq --raw-output .structured_output.branch )"
  if [[ "$name" == "null" || ! "$name" =~ ^[a-z][-a-z0-9.]+$ ]]; then
    echo "Bad bookmark from the stupid llm: '$name'"
    exit 1
  fi
fi
bookmark="$(jj config get jds.pr-prefix)$name"
if "$dry_run"; then
  echo Dry run! Would have run:
  echo jj git push --named "$bookmark=$rev"
  echo gh pr create --head "$bookmark" --web
else
  jj git push --named "$bookmark=$rev"
  gh pr create --head "$bookmark" --web
fi
